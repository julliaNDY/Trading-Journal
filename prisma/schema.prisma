generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String              @id @db.Uuid
  email              String              @unique
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  discordUsername    String?
  nickname           String? // Surnom public pour le partage de playbooks
  isBlocked          Boolean             @default(false)
  stripeCustomerId   String?             @unique // Stripe Customer ID
  avatarUrl          String? // URL de l'avatar (stocké dans Supabase Storage)
  preferredLocale    String?             @default("fr") // Langue préférée (fr/en)
  accounts           Account[]
  dayJournals        DayJournal[]
  dayVoiceNotes      DayVoiceNote[]
  importProfiles     ImportProfile[]
  playbooks          Playbook[]
  screenshots        Screenshot[]
  tags               Tag[]
  trades             Trade[]
  voiceNotes         VoiceNote[]
  subscription       Subscription?
  brokerConnections  BrokerConnection[]
  coachConversations CoachConversation[]
  feedbacks          UserFeedback[]

  @@map("users")
}

model Trade {
  id                   String          @id @default(uuid()) @db.Uuid
  userId               String          @db.Uuid
  symbol               String
  direction            Direction
  openedAt             DateTime
  closedAt             DateTime
  entryPrice           Decimal         @db.Decimal(18, 8)
  exitPrice            Decimal         @db.Decimal(18, 8)
  quantity             Decimal         @db.Decimal(18, 8)
  realizedPnlUsd       Decimal         @db.Decimal(18, 2)
  floatingRunupUsd     Decimal?        @db.Decimal(18, 2)
  floatingDrawdownUsd  Decimal?        @db.Decimal(18, 2)
  stopLossPriceInitial Decimal?        @db.Decimal(18, 8)
  riskRewardRatio      Decimal?        @db.Decimal(10, 4)
  pointValue           Decimal         @default(1.00000000) @db.Decimal(18, 8)
  importHash           String?         @unique
  tradeSignature       String?
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt
  accountId            String?         @db.Uuid
  fees                 Decimal?        @db.Decimal(18, 2)
  grossPnlUsd          Decimal?        @db.Decimal(18, 2)
  note                 String?
  plannedRMultiple     Decimal?        @db.Decimal(10, 4)
  points               Decimal?        @db.Decimal(18, 4)
  profitTarget         Decimal?        @db.Decimal(18, 8)
  rating               Int?
  realizedRMultiple    Decimal?        @db.Decimal(10, 4)
  ticksPerContract     Decimal?        @db.Decimal(18, 4)
  youtubeUrl           String?
  timesManuallySet     Boolean         @default(false)
  reviewed             Boolean         @default(false)
  hasPartialExits      Boolean         @default(false)
  screenshots          Screenshot[]
  tradePlaybooks       TradePlaybook[]
  tags                 TradeTag[]
  partialExits         TradeExit[]
  voiceNotes           VoiceNote[]
  account              Account?        @relation(fields: [accountId], references: [id])
  user                 User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([accountId])
  @@index([openedAt])
  @@index([closedAt])
  @@index([symbol])
  @@index([tradeSignature])
  @@map("trades")
}

model TradeExit {
  id        String   @id @default(uuid()) @db.Uuid
  tradeId   String   @db.Uuid
  exitPrice Decimal  @db.Decimal(18, 8)
  quantity  Decimal  @db.Decimal(18, 8)
  exitedAt  DateTime
  pnl       Decimal  @db.Decimal(18, 2)
  createdAt DateTime @default(now())
  trade     Trade    @relation(fields: [tradeId], references: [id], onDelete: Cascade)

  @@index([tradeId])
  @@map("trade_exits")
}

model DayJournal {
  id          String         @id @default(uuid()) @db.Uuid
  userId      String         @db.Uuid
  date        DateTime       @db.Date
  note        String?
  youtubeUrl  String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags        DayTag[]
  screenshots Screenshot[]
  voiceNotes  DayVoiceNote[]

  @@unique([userId, date])
  @@index([userId])
  @@map("day_journals")
}

model DayVoiceNote {
  id                String     @id @default(uuid()) @db.Uuid
  dayJournalId      String     @db.Uuid
  userId            String     @db.Uuid
  filePath          String
  duration          Int // duration in seconds
  transcription     String? // Filled by Whisper API
  transcriptionHash String? // MD5 hash for cache invalidation
  summary           String? // Filled by LLM (JSON stringified)
  createdAt         DateTime   @default(now())
  dayJournal        DayJournal @relation(fields: [dayJournalId], references: [id], onDelete: Cascade)
  user              User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([dayJournalId])
  @@index([userId])
  @@map("day_voice_notes")
}

model Tag {
  id          String     @id @default(uuid()) @db.Uuid
  userId      String     @db.Uuid
  name        String
  color       String     @default("#6366f1")
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  dayJournals DayTag[]
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  trades      TradeTag[]

  @@unique([userId, name])
  @@index([userId])
  @@map("tags")
}

model TradeTag {
  tradeId String @db.Uuid
  tagId   String @db.Uuid
  tag     Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  trade   Trade  @relation(fields: [tradeId], references: [id], onDelete: Cascade)

  @@id([tradeId, tagId])
  @@index([tagId], map: "trade_tags_tagId_idx")
  @@map("trade_tags")
}

model DayTag {
  dayJournalId String     @db.Uuid
  tagId        String     @db.Uuid
  dayJournal   DayJournal @relation(fields: [dayJournalId], references: [id], onDelete: Cascade)
  tag          Tag        @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([dayJournalId, tagId])
  @@index([tagId], map: "day_tags_tagId_idx")
  @@map("day_tags")
}

model Screenshot {
  id           String      @id @default(uuid()) @db.Uuid
  userId       String      @db.Uuid
  tradeId      String?     @db.Uuid
  dayJournalId String?     @db.Uuid
  filePath     String
  originalName String
  createdAt    DateTime    @default(now())
  dayJournal   DayJournal? @relation(fields: [dayJournalId], references: [id], onDelete: Cascade)
  trade        Trade?      @relation(fields: [tradeId], references: [id], onDelete: Cascade)
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tradeId])
  @@index([dayJournalId])
  @@map("screenshots")
}

model ImportProfile {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  name      String
  mapping   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
  @@map("import_profiles")
}

model Playbook {
  id                 String             @id @default(uuid()) @db.Uuid
  userId             String             @db.Uuid
  name               String
  description        String?
  visibility         PlaybookVisibility @default(PRIVATE)
  shareToken         String?            @unique @db.Uuid
  originalPlaybookId String?            @db.Uuid
  originalAuthorId   String?            @db.Uuid
  viewCount          Int                @default(0)
  importCount        Int                @default(0)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  groups             PlaybookGroup[]
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  tradePlaybooks     TradePlaybook[]

  @@unique([userId, name])
  @@index([userId])
  @@index([visibility])
  @@index([shareToken])
  @@map("playbooks")
}

model PlaybookGroup {
  id            String                 @id @default(uuid()) @db.Uuid
  playbookId    String                 @db.Uuid
  name          String
  order         Int                    @default(0)
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @updatedAt
  playbook      Playbook               @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  prerequisites PlaybookPrerequisite[]

  @@index([playbookId])
  @@map("playbook_groups")
}

model PlaybookPrerequisite {
  id                   String                      @id @default(uuid()) @db.Uuid
  groupId              String                      @db.Uuid
  text                 String
  order                Int                         @default(0)
  createdAt            DateTime                    @default(now())
  updatedAt            DateTime                    @updatedAt
  group                PlaybookGroup               @relation(fields: [groupId], references: [id], onDelete: Cascade)
  checkedPrerequisites TradePlaybookPrerequisite[]

  @@index([groupId])
  @@map("playbook_prerequisites")
}

model TradePlaybook {
  id                   String                      @id @default(uuid()) @db.Uuid
  tradeId              String                      @db.Uuid
  playbookId           String                      @db.Uuid
  createdAt            DateTime                    @default(now())
  checkedPrerequisites TradePlaybookPrerequisite[]
  playbook             Playbook                    @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  trade                Trade                       @relation(fields: [tradeId], references: [id], onDelete: Cascade)

  @@unique([tradeId, playbookId])
  @@index([tradeId])
  @@index([playbookId])
  @@map("trade_playbooks")
}

model TradePlaybookPrerequisite {
  tradePlaybookId String               @db.Uuid
  prerequisiteId  String               @db.Uuid
  checked         Boolean              @default(false)
  prerequisite    PlaybookPrerequisite @relation(fields: [prerequisiteId], references: [id], onDelete: Cascade)
  tradePlaybook   TradePlaybook        @relation(fields: [tradePlaybookId], references: [id], onDelete: Cascade)

  @@id([tradePlaybookId, prerequisiteId])
  @@index([prerequisiteId], map: "trade_playbook_prereq_prereqId_idx")
  @@map("trade_playbook_prerequisites")
}

model Account {
  id                String             @id @default(uuid()) @db.Uuid
  userId            String             @db.Uuid
  name              String
  broker            String?
  description       String?
  color             String             @default("#6366f1")
  initialBalance    Decimal?           @db.Decimal(18, 2)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  trades            Trade[]
  brokerConnections BrokerConnection[]

  @@unique([userId, name])
  @@index([userId])
  @@map("accounts")
}

model VoiceNote {
  id                String   @id @default(uuid()) @db.Uuid
  tradeId           String   @db.Uuid
  userId            String   @db.Uuid
  filePath          String
  duration          Int // duration in seconds
  transcription     String? // Filled by story 5.2 (Whisper transcription)
  transcriptionHash String? // MD5 hash for cache invalidation
  summary           String? // Filled by story 5.3 (LLM summary) - JSON stringified Summary
  createdAt         DateTime @default(now())
  trade             Trade    @relation(fields: [tradeId], references: [id], onDelete: Cascade)
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tradeId])
  @@index([userId])
  @@map("voice_notes")
}

enum Direction {
  LONG
  SHORT
  UNKNOWN
}

enum PlaybookVisibility {
  PRIVATE
  UNLISTED
  PUBLIC
}

// ==================== SUBSCRIPTION SYSTEM ====================

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  BETA_ACCESS
  PAST_DUE
  CANCELED
  EXPIRED
}

enum PlanInterval {
  BETA
  MONTHLY
  QUARTERLY
  BIANNUAL
  ANNUAL
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model Plan {
  id            String         @id @default(uuid()) @db.Uuid
  name          String         @unique
  displayName   String? // Display name for UI (e.g., "Pro Mensuel")
  description   String?
  price         Decimal        @db.Decimal(10, 2)
  interval      PlanInterval
  stripePriceId String?        @unique // Stripe Price ID
  features      Json           @default("[]")
  isActive      Boolean        @default(true)
  trialDays     Int            @default(7) // 7 days trial by default
  sortOrder     Int            @default(0) // For ordering in UI
  savings       String? // e.g., "-33%" for display
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  subscriptions Subscription[]

  @@map("plans")
}

model Subscription {
  id                   String             @id @default(uuid()) @db.Uuid
  userId               String             @unique @db.Uuid
  planId               String             @db.Uuid
  stripeSubscriptionId String?            @unique // Stripe Subscription ID
  status               SubscriptionStatus @default(TRIAL)
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  canceledAt           DateTime?
  trialEndsAt          DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan                 Plan               @relation(fields: [planId], references: [id])
  invoices             Invoice[]

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([stripeSubscriptionId])
  @@map("subscriptions")
}

model Invoice {
  id              String        @id @default(uuid()) @db.Uuid
  subscriptionId  String        @db.Uuid
  stripeInvoiceId String?       @unique // Stripe Invoice ID
  invoiceNumber   String        @unique
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("EUR")
  status          PaymentStatus @default(PENDING)
  dueDate         DateTime
  paidAt          DateTime?
  invoicePdfUrl   String? // Stripe hosted invoice PDF URL
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  subscription    Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  payments        Payment[]

  @@index([subscriptionId])
  @@index([status])
  @@index([stripeInvoiceId])
  @@map("invoices")
}

model Payment {
  id                String        @id @default(uuid()) @db.Uuid
  invoiceId         String        @db.Uuid
  amount            Decimal       @db.Decimal(10, 2)
  currency          String        @default("EUR")
  status            PaymentStatus @default(PENDING)
  paymentMethod     String?
  externalPaymentId String?
  metadata          Json?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  invoice           Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@index([externalPaymentId])
  @@map("payments")
}

// ============================================================================
// BROKER SYNC MODELS
// ============================================================================

enum BrokerType {
  TRADOVATE
  IBKR
  // Future brokers can be added here
}

enum BrokerConnectionStatus {
  PENDING // Credentials entered, not validated yet
  CONNECTED // Validated and active
  ERROR // Connection error (invalid credentials, rate limit, etc.)
  DISCONNECTED // User manually disconnected
}

enum SyncStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

model BrokerConnection {
  id         String                 @id @default(uuid()) @db.Uuid
  userId     String                 @db.Uuid
  brokerType BrokerType
  status     BrokerConnectionStatus @default(PENDING)

  // Encrypted credentials (API Key + Secret for Tradovate)
  encryptedApiKey    String?
  encryptedApiSecret String?

  // Tradovate-specific: access token (refreshed periodically)
  accessToken    String?
  tokenExpiresAt DateTime?

  // Broker account info (fetched after auth)
  brokerAccountId   String? // The account ID from the broker
  brokerAccountName String? // Display name

  // Sync configuration
  syncEnabled     Boolean   @default(true)
  syncIntervalMin Int       @default(15) // Sync every N minutes
  lastSyncAt      DateTime?
  lastSyncError   String?

  // Link to local trading account
  accountId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  account  Account?  @relation(fields: [accountId], references: [id], onDelete: SetNull)
  syncLogs SyncLog[]

  @@unique([userId, brokerType, brokerAccountId])
  @@index([userId])
  @@index([brokerType])
  @@index([status])
  @@map("broker_connections")
}

model SyncLog {
  id                 String     @id @default(uuid()) @db.Uuid
  brokerConnectionId String     @db.Uuid
  status             SyncStatus @default(PENDING)

  // Sync results
  tradesImported Int @default(0)
  tradesSkipped  Int @default(0) // Duplicates
  tradesUpdated  Int @default(0)

  // Timing
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  durationMs  Int?

  // Error details
  errorMessage String?
  errorDetails Json?

  // Metadata
  syncType String @default("scheduled") // "scheduled" | "manual"

  brokerConnection BrokerConnection @relation(fields: [brokerConnectionId], references: [id], onDelete: Cascade)

  @@index([brokerConnectionId])
  @@index([status])
  @@index([startedAt])
  @@map("sync_logs")
}

// ============================================================================
// AI COACH MODELS (Epic 7)
// ============================================================================

enum FeedbackType {
  LIKE
  DISLIKE
}

enum FeedbackCategory {
  SUGGESTION // User suggestion for improvement
  BUG_REPORT // Bug or issue report
  COACH_FEEDBACK // Feedback on AI coach response
  GENERAL // General feedback
}

model CoachConversation {
  id        String         @id @default(uuid()) @db.Uuid
  userId    String         @db.Uuid
  title     String?
  context   Json? // Trading context at conversation start (stats, recent trades)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  messages  CoachMessage[]
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@map("coach_conversations")
}

model CoachMessage {
  id             String            @id @default(uuid()) @db.Uuid
  conversationId String            @db.Uuid
  role           String // "user" | "assistant"
  content        String
  feedback       FeedbackType? // User feedback on assistant messages
  createdAt      DateTime          @default(now())
  conversation   CoachConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("coach_messages")
}

model UserFeedback {
  id        String           @id @default(uuid()) @db.Uuid
  userId    String           @db.Uuid
  category  FeedbackCategory
  title     String?
  content   String
  metadata  Json? // Additional context (page, feature, etc.)
  resolved  Boolean          @default(false)
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([category])
  @@index([resolved])
  @@map("user_feedbacks")
}
