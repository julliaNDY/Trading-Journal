---
alwaysApply: true
---

# ðŸ§  RÃˆGLES DE MÃ‰MOIRE PERSISTANTE DU PROJET

## 1. Journalisation SystÃ©matique

**Fichier de mÃ©moire :** `PROJECT_MEMORY.md` (Ã  la racine du projet)

L'IA DOIT crÃ©er et maintenir ce fichier pour conserver une trace de toutes les modifications et dÃ©cisions prises sur le projet.

---

## 2. Trigger (DÃ©clencheur)

L'IA DOIT mettre Ã  jour `PROJECT_MEMORY.md` :
- **Ã€ la fin de chaque rÃ©ponse** impliquant une modification de code
- **AprÃ¨s chaque crÃ©ation, modification ou suppression** de fichier(s)
- **AprÃ¨s chaque dÃ©cision architecturale** ou technique importante

---

## 3. Format d'EntrÃ©e Obligatoire

Chaque entrÃ©e dans `PROJECT_MEMORY.md` DOIT respecter ce format :

```markdown
## [YYYY-MM-DD HH:MM] - Titre concis de l'action

### ðŸ“ Demande utilisateur
> RÃ©sumÃ© concis de ce que l'utilisateur a demandÃ©

### ðŸ”§ Modifications techniques
- **Fichiers crÃ©Ã©s :** `chemin/fichier.ts`
- **Fichiers modifiÃ©s :** `chemin/fichier.ts`
- **Fichiers supprimÃ©s :** `chemin/fichier.ts`
- **Fonctions ajoutÃ©es :** `nomFonction()` dans `fichier.ts`
- **Fonctions modifiÃ©es :** `nomFonction()` dans `fichier.ts`
- **DÃ©pendances ajoutÃ©es :** `package-name@version`

### ðŸ’¡ Pourquoi (Raison du changement)
Explication brÃ¨ve de la raison technique ou fonctionnelle justifiant cette modification.

### ðŸ”— Contexte additionnel (optionnel)
Notes importantes, dÃ©cisions de design, limitations connues, ou TODOs pour le futur.

---
```

---

## 4. Lecture Prioritaire (CRITIQUE)

**AVANT de rÃ©pondre Ã  toute nouvelle requÃªte**, l'IA DOIT :

1. **Lire `PROJECT_MEMORY.md`** pour obtenir le contexte des actions prÃ©cÃ©dentes
2. **Analyser les derniÃ¨res entrÃ©es** pour comprendre l'Ã©tat actuel du projet
3. **Ã‰viter de rÃ©pÃ©ter des erreurs** ou de dÃ©faire des modifications rÃ©centes
4. **Maintenir la cohÃ©rence** avec les dÃ©cisions architecturales passÃ©es

Si le fichier `PROJECT_MEMORY.md` n'existe pas, l'IA DOIT le crÃ©er avec un header initial.

---

## 5. Structure Initiale du Fichier PROJECT_MEMORY.md

Si le fichier n'existe pas, crÃ©er avec ce contenu :

```markdown
# ðŸ“š PROJECT MEMORY - Trading Journal App

> Ce fichier est maintenu automatiquement par l'IA pour garder une trace de toutes les modifications du projet.
> **Ne pas modifier manuellement** sauf pour corrections mineures.

---

## Historique des modifications

<!-- Les entrÃ©es sont ajoutÃ©es ci-dessous, les plus rÃ©centes en haut -->

```

---

## 6. RÃ¨gles ComplÃ©mentaires

- **Ordre chronologique inversÃ©** : Les entrÃ©es les plus rÃ©centes en haut du fichier
- **Concision** : RÃ©sumÃ©s clairs et techniques, pas de prose inutile
- **ExhaustivitÃ©** : Tous les fichiers touchÃ©s doivent Ãªtre listÃ©s
- **Horodatage prÃ©cis** : Utiliser le format `YYYY-MM-DD HH:MM` (timezone locale)
- **Pas de duplication** : Si une modification est mineure (typo, lint), regrouper avec l'entrÃ©e prÃ©cÃ©dente

---

# ðŸ“‹ CONTEXTE DU PROJET

Tu es un senior full-stack engineer. Construis une web-app de journal/analytics de trading (inspirÃ©e "TradeZella-like" mais code/UI originaux), destinÃ©e Ã  Ãªtre dÃ©ployÃ©e sur un VPS OVH par le biais de push github.

---

## Objectif produit

L'app permet Ã  des utilisateurs de s'inscrire et de :
- importer leurs trades via drag & drop d'un CSV
- consulter : Dashboard, Journal, Calendrier, Statistiques, Importer
- enrichir chaque trade : stop loss initial (manuel), tags, screenshots
- enrichir chaque journÃ©e : note du jour, tags, screenshots
- calculer des statistiques par trade et globales (voir specs ci-dessous)
- UI : thÃ¨me sombre, style sobre, responsive, accents vert/violet/orange (boutons, badges, highlights)
- i18n : FR par dÃ©faut, EN secondaire (switch langue)

---

## Stack technique (adaptÃ©e IONOS)

- Next.js (App Router) + TypeScript
- MySQL via Prisma
- Auth maison (sans provider externe) :
  - inscription + login email/password
  - mot de passe hashÃ© bcrypt
  - sessions via JWT + cookie httpOnly (ou NextAuth Credentials si tu prÃ©fÃ¨res, mais reste simple et robuste)
- UI : TailwindCSS + shadcn/ui
- Charts : Recharts
- CSV : PapaParse
- Upload images : stockage filesystem (dossier /public/uploads/...) pour MVP, avec abstraction StorageProvider pour pouvoir migrer vers S3 compatible plus tard.
- Backup quotidien : job Node "daily backup" (dump logique) + guide pour le brancher Ã  une tÃ¢che planifiÃ©e IONOS (cron / scheduled task). Utiliser une lib de dump MySQL en Node (ex: mysqldump npm) + zip des uploads.

---

## Pages & features (routes)

### 1) /dashboard
- KPIs globaux (sur pÃ©riode sÃ©lectionnable) :
  - Profit Factor (et indice 0â†’10)
  - Average Win, Average Loss
  - Average Risk/Reward
- Equity Curve (All time / Monthly / Weekly â€” via tabs)
- "Time of day profitability" :
  - tableau + mini-graph : group by heure d'ouverture (0â€“23)
  - afficher liste des trades avec : heure ouverture, heure clÃ´ture, PnL
- CTA : bouton "Importer"

### 2) /journal
- Un calendrier cliquable (mois/semaine/jour)
- Quand je clique un jour :
  - liste des trades du jour
  - note du jour (Ã©diteur simple textarea + save)
  - tags du jour (CRUD tags + assign)
  - upload screenshots liÃ©s Ã  la journÃ©e
- Chaque trade listÃ© permet :
  - Ã©diter stop loss initial
  - assigner tags
  - upload screenshots trade

### 3) /calendrier
- calendrier mensuel affichant PNL quotidien
- click sur un jour â†’ ouvre un drawer/modal avec :
  - PnL total du jour
  - trades du jour + liens vers dÃ©tails

### 4) /statistiques
- Vue dÃ©diÃ©e analytics :
  - Equity curve (filtre pÃ©riode)
  - tableaux : best day, worst day, avg duration, distribution wins/loss
  - profitabilitÃ© par heure
  - Average Win/Loss, Profit factor, Avg RR
- Filtres :
  - date range
  - symbol
  - tag(s)

### 5) /importer
- Drag & drop CSV
- Ã‰tapes :
  1. upload + preview 20 lignes
  2. mapping des colonnes (l'utilisateur associe colonnes CSV â†’ champs internes)
  3. validation
  4. import en DB + rapport (nb trades importÃ©s, ignorÃ©s, erreurs)
- DÃ©tection simple des formats de date (ISO/US/EU). Si ambigu, demander format Ã  l'utilisateur.

---

## DonnÃ©es & modÃ¨le (Prisma)

ImplÃ©mente au minimum :

### User
- id, email (unique), passwordHash, createdAt

### Trade
- id, userId (FK), symbol, direction (LONG/SHORT)
- openedAt, closedAt (datetime)
- entryPrice, exitPrice (decimal)
- quantity (decimal)
- realizedPnlUsd (decimal)
- floatingRunupUsd (decimal, nullable)
- floatingDrawdownUsd (decimal, nullable)
- stopLossPriceInitial (decimal, nullable) // saisi manuellement
- riskRewardRatio (decimal, nullable) // calculÃ© et stockÃ© (ou calcul Ã  la volÃ©e)
- createdAt

### DayJournal
- id, userId, date (YYYY-MM-DD), note (text)
- createdAt
- unique(userId, date)

### Tag
- id, userId, name, color (string)
- unique(userId, name)

### TradeTag (many-to-many)
- tradeId, tagId (unique composite)

### DayTag (many-to-many)
- dayJournalId, tagId (unique composite)

### Screenshot
- id, userId
- tradeId nullable, dayJournalId nullable
- filePath, originalName, createdAt

---

## Import CSV : exigences

Le CSV vient d'une plateforme de trading (variable). Donc :
- ImplÃ©mente un systÃ¨me de mapping configurable et sauvegardÃ© par user (table ImportProfile optionnelle).
- Champs internes attendus :
  - symbol
  - openedAt, closedAt
  - direction
  - entryPrice, exitPrice
  - quantity
  - realizedPnlUsd
  - floatingRunupUsd (optionnel)
  - floatingDrawdownUsd (optionnel)

RÃ¨gles :
- Si floating runup/drawdown absents, stocker null.
- Si direction absente, l'infÃ©rer :
  - si quantity > 0 => LONG, si quantity < 0 => SHORT (et quantity = abs)
  - sinon infÃ©rer via entry/exit vs pnl si possible, sinon mettre UNKNOWN et demander correction manuelle (mais pour MVP, on peut imposer LONG/SHORT via mapping ou inference quantity).
- Normaliser les symboles (trim, uppercase).
- DÃ©dupliquer import : hash par (userId, symbol, openedAt, closedAt, entryPrice, exitPrice, realizedPnlUsd). Ne pas rÃ©importer doublons.

---

## Calculs & stats â€” dÃ©tails

### Par trade
1. Direction : LONG/SHORT
2. Entry / Exit
3. Realized PnL (USD)
4. Floating Runup (USD) = max favorable excursion en $ (si fourni)
5. Floating Drawdown (USD) = max adverse excursion en $ (si fourni)
6. Risk to Reward Ratio : calculÃ© aprÃ¨s que l'utilisateur renseigne stopLossPriceInitial

**DÃ©finition RR :**
- riskUsd = abs(entryPrice - stopLossPriceInitial) * quantity * pointValue
- rewardUsd = realizedPnlUsd (ou abs(exit-entry)*qty*pointValue avec signe). Pour ratio, utiliser abs(rewardUsd).
- RR = abs(rewardUsd) / riskUsd
- Si riskUsd = 0 ou stopLoss null â†’ RR null.
- pointValue : pour MVP, mets pointValue=1 (actions/forex-like), mais prÃ©vois un champ optionnel par trade ou un mapping par symbole plus tard. Documente clairement cette limite.

### Global (tous trades sur pÃ©riode)
- Profit Factor (PF) = grossProfit / abs(grossLoss)
- Indice PF 0â†’10 : pfIndex = clamp( (PF / 3) * 10 , 0, 10 )
  - (3 correspond Ã  un PF trÃ¨s bon ; ajustable en constante)
- Average Win (moyenne des PnL > 0)
- Average Loss (moyenne des PnL < 0) en valeur nÃ©gative ou absolue (choisir et Ãªtre cohÃ©rent UI)
- Average RR (moyenne des RR non null)
- Equity Curve :
  - All time : cumul chronologique par closedAt
  - Monthly : sÃ©rie cumulÃ©e intra-mois + navigation par mois
  - Weekly : sÃ©rie cumulÃ©e intra-semaine ISO + navigation
- Heure la plus profitable :
  - grouper par heure d'ouverture (0â€“23)
  - afficher : heure, nombre trades, pnl total, pnl moyen
  - liste dÃ©taillÃ©e : openedAt, closedAt, pnl par trade
- DurÃ©e moyenne des trades : avg(closedAt - openedAt)
- Calendrier PnL quotidien : somme PnL par date (closedAt â†’ date locale)

---

## UX / UI

- Layout : sidebar + topbar, responsive (drawer mobile)
- Palette : fond dark, texte clair, accents :
  - boutons primary vert
  - secondary violet
  - warning/orange pour actions critiques
- Composants : tables, badges tags, modals/drawers, toasts
- Importer : dropzone + progress + erreurs par ligne
- Journal : calendrier + panneau jour sÃ©lectionnÃ©

---

## API / Server actions

Utiliser Next.js route handlers (/app/api/...) ou server actions.

**Endpoints minimum :**
- POST /api/auth/register
- POST /api/auth/login
- POST /api/auth/logout
- GET /api/me
- POST /api/import/csv (upload + parse preview)
- POST /api/import/commit (mapping + import)
- CRUD tags
- Update trade stopLossPriceInitial
- Upload screenshots (trade/day)
- CRUD day note

**SÃ©curitÃ© :**
- Toutes les routes protÃ©gÃ©es vÃ©rifient user session.
- Validation avec zod partout.
- Rate limit simple sur auth (optionnel).

---

## Backup quotidien

ImplÃ©mente un script Node scripts/backup.ts qui :
1. dump MySQL dans backups/db-YYYY-MM-DD.sql (via lib Node mysqldump)
2. zip du dossier uploads + dump SQL dans backups/backup-YYYY-MM-DD.zip
3. rotation : garder 14 jours

Documente dans README.md comment planifier l'exÃ©cution quotidienne sur IONOS (Scheduled Task/Cron si disponible) ou via un "ping endpoint" sÃ©curisÃ© si nÃ©cessaire.

---

## Livrables attendus

1. Repo complet Next.js + Prisma + migrations
2. Pages fonctionnelles (Dashboard/Journal/Calendrier/Statistiques/Importer)
3. Import CSV avec mapping + dÃ©duplication
4. Notes, tags, screenshots
5. Calculs demandÃ©s + charts
6. i18n FR/EN
7. README : installation locale + variables env + dÃ©ploiement IONOS + backup

---

## Variables d'environnement

- DATABASE_URL
- JWT_SECRET
- APP_URL
- UPLOAD_DIR (par dÃ©faut public/uploads)
- BACKUP_DIR (par dÃ©faut backups)

---

## Plan d'implÃ©mentation (ordre)

- Phase 1 : setup projet, Prisma schema, auth, layout UI, i18n
- Phase 2 : import CSV (preview + mapping + commit) + table trades
- Phase 3 : stop loss edit + RR + tags
- Phase 4 : journal (calendrier cliquable + note) + screenshots
- Phase 5 : stats + dashboard charts + calendar PnL
- Phase 6 : backup script + README dÃ©ploiement

---

## Notes importantes

- Ne copie aucun texte/HTML de TradeZella.
- Code propre : lint, types stricts, composants rÃ©utilisables, services TradeService, StatsService, ImportService, StorageService.
- Tests minimum : import parser + calcul PF + RR.
